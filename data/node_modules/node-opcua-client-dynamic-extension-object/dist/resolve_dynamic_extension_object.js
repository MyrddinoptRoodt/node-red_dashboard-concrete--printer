"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDynamicExtensionObject = void 0;
const node_opcua_binary_stream_1 = require("node-opcua-binary-stream");
const node_opcua_extension_object_1 = require("node-opcua-extension-object");
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const populate_data_type_manager_104_1 = require("./private/populate_data_type_manager_104");
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
function getOrExtractConstructor(session, binaryEncodingNodeId, dataTypeManager) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(binaryEncodingNodeId.namespace);
        const Constructor = dataTypeFactory.getConstructor(binaryEncodingNodeId);
        if (Constructor) {
            return Constructor;
        }
        if (binaryEncodingNodeId.namespace === 0) {
            throw new Error("Internal Error");
        }
        // need to extract it
        const browseResult = yield session.browse({
            nodeId: binaryEncodingNodeId,
            referenceTypeId: "HasEncoding",
            browseDirection: node_opcua_data_model_1.BrowseDirection.Inverse,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
            resultMask: node_opcua_data_model_1.ResultMask.BrowseName
        });
        if (browseResult.statusCode !== node_opcua_status_code_1.StatusCodes.Good || browseResult.references.length !== 1) {
            throw new Error("browse failed");
        }
        const r = browseResult.references[0];
        const dataTypeNodeId = r.nodeId;
        if (dataTypeFactory.getConstructorForDataType(dataTypeNodeId)) {
            throw new Error("Internal Error: we are not expecting this dataType to be processed already");
        }
        yield (0, populate_data_type_manager_104_1.readDataTypeDefinitionAndBuildType)(session, dataTypeNodeId, r.browseName.name, dataTypeFactory, {});
        return dataTypeFactory.getConstructorForDataType(dataTypeNodeId);
    });
}
function resolveDynamicExtensionObjectV(session, opaque, dataTypeManager) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const Constructor = yield getOrExtractConstructor(session, opaque.nodeId, dataTypeManager);
            const object = new Constructor();
            const stream = new node_opcua_binary_stream_1.BinaryStream(opaque.buffer);
            try {
                object.decode(stream);
                return object;
            }
            catch (err) {
                warningLog("Constructor = ", Constructor.name);
                warningLog("opaqueStructure = ", (_a = opaque === null || opaque === void 0 ? void 0 : opaque.nodeId) === null || _a === void 0 ? void 0 : _a.toString());
                warningLog("opaqueStructure = ", "0x" + ((_b = opaque === null || opaque === void 0 ? void 0 : opaque.buffer) === null || _b === void 0 ? void 0 : _b.toString("hex")));
                warningLog((0, node_opcua_debug_1.hexDump)(opaque.buffer));
                warningLog("resolveDynamicExtensionObjectV err = ", err);
                // try again for debugging
                object.decode(stream);
                return opaque;
            }
        }
        catch (err) {
            warningLog("err", err);
            warningLog("opaqueStructure = ", opaque.nodeId.toString());
            warningLog("opaqueStructure = ", "0x" + opaque.buffer.toString("hex"));
            warningLog((0, node_opcua_debug_1.hexDump)(opaque.buffer));
            warningLog(dataTypeManager.toString());
            throw err;
        }
    });
}
function resolveDynamicExtensionObject(session, variant, dataTypeManager) {
    return __awaiter(this, void 0, void 0, function* () {
        if (variant.dataType !== node_opcua_variant_1.DataType.ExtensionObject) {
            return;
        }
        if (variant.arrayType !== node_opcua_variant_1.VariantArrayType.Scalar) {
            if (variant.value instanceof Array) {
                for (let i = 0; i < variant.value.length; i++) {
                    if (variant.value[i] instanceof node_opcua_extension_object_1.OpaqueStructure) {
                        variant.value[i] = yield resolveDynamicExtensionObjectV(session, variant.value[i], dataTypeManager);
                    }
                }
            }
            return;
        }
        if (!(variant.value instanceof node_opcua_extension_object_1.OpaqueStructure)) {
            return;
        }
        variant.value = yield resolveDynamicExtensionObjectV(session, variant.value, dataTypeManager);
    });
}
exports.resolveDynamicExtensionObject = resolveDynamicExtensionObject;
//# sourceMappingURL=resolve_dynamic_extension_object.js.map