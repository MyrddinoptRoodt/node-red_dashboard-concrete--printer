"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateDataTypeManager104 = exports.readDataTypeDefinitionAndBuildType = void 0;
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_schemas_1 = require("node-opcua-schemas");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const convert_data_type_definition_to_structuretype_schema_1 = require("../convert_data_type_definition_to_structuretype_schema");
const node_opcua_debug_1 = require("node-opcua-debug");
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
function readDataTypeDefinitionAndBuildType(session, dataTypeNodeId, name, dataTypeFactory, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const dataTypeDefinitionDataValue = yield session.read({
                attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition,
                nodeId: dataTypeNodeId
            });
            /* istanbul ignore next */
            if (dataTypeDefinitionDataValue.statusCode !== node_opcua_status_code_1.StatusCodes.Good) {
                throw new Error(" Cannot find dataType Definition ! with nodeId =" + dataTypeNodeId.toString());
            }
            const dataTypeDefinition = dataTypeDefinitionDataValue.value.value;
            const schema = yield (0, convert_data_type_definition_to_structuretype_schema_1.convertDataTypeDefinitionToStructureTypeSchema)(session, dataTypeNodeId, name, dataTypeDefinition, dataTypeFactory, cache);
            (0, node_opcua_schemas_1.createDynamicObjectConstructor)(schema, dataTypeFactory);
        }
        catch (err) {
            errorLog("Error", err);
        }
    });
}
exports.readDataTypeDefinitionAndBuildType = readDataTypeDefinitionAndBuildType;
function populateDataTypeManager104(session, dataTypeManager) {
    return __awaiter(this, void 0, void 0, function* () {
        const cache = {};
        function withDataType(dataTypeNodeId, r) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const dataTypeFactory = dataTypeManager.getDataTypeFactory(dataTypeNodeId.namespace);
                    if (dataTypeNodeId.namespace === 0) {
                        // already known I guess
                        return;
                    }
                    // if not found already
                    if (dataTypeFactory.getConstructorForDataType(dataTypeNodeId)) {
                        // already known !
                        return;
                    }
                    // extract it formally
                    debugLog(" DataType => ", r.browseName.toString(), dataTypeNodeId.toString());
                    yield readDataTypeDefinitionAndBuildType(session, dataTypeNodeId, r.browseName.name, dataTypeFactory, cache);
                    (0, node_opcua_assert_1.assert)(dataTypeFactory.getConstructorForDataType(dataTypeNodeId));
                }
                catch (err) {
                    errorLog("err=", err);
                }
            });
        }
        function performAction(done) {
            let pendingNodesToBrowse = [];
            let pendingContinuationPoints = [];
            function triggerFutureBrowse() {
                if (pendingNodesToBrowse.length + pendingContinuationPoints.length === 1) {
                    fencedAction(() => __awaiter(this, void 0, void 0, function* () {
                        flushBrowse();
                    }));
                }
            }
            let busyCount = 0;
            function processBrowseResult(browseResults) {
                for (const result of browseResults) {
                    if (result.statusCode === node_opcua_status_code_1.StatusCodes.Good) {
                        if (result.continuationPoint) {
                            pendingContinuationPoints.push(result.continuationPoint);
                            triggerFutureBrowse();
                        }
                        for (const r of result.references || []) {
                            const dataTypeNodeId = r.nodeId;
                            fencedAction(() => __awaiter(this, void 0, void 0, function* () {
                                yield withDataType(dataTypeNodeId, r);
                            }));
                            // also explore sub types
                            browseSubDataTypeRecursively(dataTypeNodeId);
                        }
                    }
                }
            }
            function fencedAction(lambda) {
                return __awaiter(this, void 0, void 0, function* () {
                    busyCount += 1;
                    yield lambda();
                    busyCount -= 1;
                    flushBrowse();
                });
            }
            function flushBrowse() {
                (0, node_opcua_assert_1.assert)(busyCount >= 0);
                if (pendingContinuationPoints.length) {
                    const continuationPoints = pendingContinuationPoints;
                    pendingContinuationPoints = [];
                    fencedAction(() => __awaiter(this, void 0, void 0, function* () {
                        const browseResults = yield session.browseNext(continuationPoints, false);
                        processBrowseResult(browseResults);
                    }));
                }
                else if (pendingNodesToBrowse.length) {
                    const nodesToBrowse = pendingNodesToBrowse;
                    pendingNodesToBrowse = [];
                    fencedAction(() => __awaiter(this, void 0, void 0, function* () {
                        const browseResults = yield session.browse(nodesToBrowse);
                        processBrowseResult(browseResults);
                    }));
                }
                else if (pendingContinuationPoints.length + pendingNodesToBrowse.length === 0 && busyCount === 0) {
                    done();
                }
            }
            function browseSubDataTypeRecursively(nodeId) {
                const nodeToBrowse = {
                    nodeId,
                    includeSubtypes: true,
                    browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
                    nodeClassMask: 0xff,
                    referenceTypeId: (0, node_opcua_nodeid_1.resolveNodeId)("HasSubtype"),
                    resultMask: 0xff
                };
                pendingNodesToBrowse.push(nodeToBrowse);
                triggerFutureBrowse();
            }
            browseSubDataTypeRecursively((0, node_opcua_nodeid_1.resolveNodeId)("Structure"));
        }
        yield new Promise((resolve) => performAction(resolve));
    });
}
exports.populateDataTypeManager104 = populateDataTypeManager104;
//# sourceMappingURL=populate_data_type_manager_104.js.map