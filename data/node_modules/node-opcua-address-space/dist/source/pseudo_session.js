"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PseudoSession = void 0;
/**
 * @module node-opcua-address-space
 */
const util_1 = require("util");
const async = require("async");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_value_1 = require("node-opcua-data-value");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_service_browse_1 = require("node-opcua-service-browse");
const node_opcua_service_call_1 = require("node-opcua-service-call");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_basic_types_1 = require("node-opcua-basic-types");
const continuation_point_manager_1 = require("./continuation_points/continuation_point_manager");
const call_helpers_1 = require("./helpers/call_helpers");
const session_context_1 = require("./session_context");
const errorLog = (0, node_opcua_debug_1.make_errorLog)("PseudoSession");
/**
 * Pseudo session is an helper object that exposes the same async methods
 * than the ClientSession. It can be used on a server address space.
 *
 * Code reused !
 * The primary benefit of this object  is that its makes advanced OPCUA
 * operations that uses browse, translate, read, write etc similar
 * whether we work inside a server or through a client session.
 *
 */
class PseudoSession {
    constructor(addressSpace, context) {
        this.requestedMaxReferencesPerNode = 0;
        this._sessionId = new node_opcua_nodeid_1.NodeId(node_opcua_nodeid_1.NodeIdType.GUID, (0, node_opcua_basic_types_1.randomGuid)());
        this.addressSpace = addressSpace;
        this.context = context || session_context_1.SessionContext.defaultContext;
        this.continuationPointManager = new continuation_point_manager_1.ContinuationPointManager();
    }
    getSessionId() {
        return this._sessionId;
    }
    browse(nodesToBrowse, callback) {
        setImmediate(() => {
            const isArray = Array.isArray(nodesToBrowse);
            if (!isArray) {
                nodesToBrowse = [nodesToBrowse];
            }
            let results = [];
            for (const browseDescription of nodesToBrowse) {
                browseDescription.referenceTypeId = (0, node_opcua_nodeid_1.resolveNodeId)(browseDescription.referenceTypeId);
                const _browseDescription = browseDescription instanceof node_opcua_service_browse_1.BrowseDescription ? browseDescription : new node_opcua_service_browse_1.BrowseDescription(browseDescription);
                const nodeId = (0, node_opcua_nodeid_1.resolveNodeId)(_browseDescription.nodeId);
                const r = this.addressSpace.browseSingleNode(nodeId, _browseDescription, this.context);
                results.push(r);
            }
            // handle continuation points
            results = results.map((result, index) => {
                (0, node_opcua_assert_1.assert)(!result.continuationPoint);
                const r = this.continuationPointManager.registerReferences(this.requestedMaxReferencesPerNode, result.references || [], { continuationPoint: null, index });
                let { statusCode } = r;
                const { continuationPoint, values } = r;
                (0, node_opcua_assert_1.assert)(statusCode === node_opcua_status_code_1.StatusCodes.Good || statusCode === node_opcua_status_code_1.StatusCodes.GoodNoData);
                statusCode = result.statusCode;
                return new node_opcua_service_browse_1.BrowseResult({
                    statusCode,
                    continuationPoint,
                    references: values
                });
            });
            callback(null, isArray ? results : results[0]);
        });
    }
    read(nodesToRead, callback) {
        const isArray = Array.isArray(nodesToRead);
        if (!isArray) {
            nodesToRead = [nodesToRead];
        }
        const _nodesToRead = nodesToRead;
        const context = this.context;
        setImmediate(() => {
            async.map(_nodesToRead, (nodeToRead, innerCallback) => {
                const obj = this.addressSpace.findNode(nodeToRead.nodeId);
                if (!obj || obj.nodeClass !== node_opcua_data_model_1.NodeClass.Variable || nodeToRead.attributeId !== node_opcua_data_model_1.AttributeIds.Value) {
                    return innerCallback();
                }
                obj.readValueAsync(context, innerCallback);
            }, (err) => {
                const dataValues = _nodesToRead.map((nodeToRead) => {
                    (0, node_opcua_assert_1.assert)(!!nodeToRead.nodeId, "expecting a nodeId");
                    (0, node_opcua_assert_1.assert)(!!nodeToRead.attributeId, "expecting a attributeId");
                    const nodeId = nodeToRead.nodeId;
                    const attributeId = nodeToRead.attributeId;
                    const indexRange = nodeToRead.indexRange;
                    const dataEncoding = nodeToRead.dataEncoding;
                    const obj = this.addressSpace.findNode(nodeId);
                    if (!obj) {
                        return new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadNodeIdUnknown });
                    }
                    const context = this.context;
                    const dataValue = obj.readAttribute(context, attributeId, indexRange, dataEncoding);
                    return dataValue;
                });
                callback(null, isArray ? dataValues : dataValues[0]);
            });
        });
    }
    browseNext(continuationPoints, releaseContinuationPoints, callback) {
        setImmediate(() => {
            if (continuationPoints instanceof Buffer) {
                return this.browseNext([continuationPoints], releaseContinuationPoints, (err, _results) => {
                    if (err) {
                        return callback(err);
                    }
                    callback(null, _results[0]);
                });
            }
            const results = continuationPoints
                .map((continuationPoint, index) => {
                return this.continuationPointManager.getNextReferences(0, {
                    continuationPoint,
                    index,
                    releaseContinuationPoints
                });
            })
                .map((r) => new node_opcua_service_browse_1.BrowseResult({
                statusCode: r.statusCode,
                continuationPoint: r.continuationPoint,
                references: r.values
            }));
            callback(null, results);
        });
    }
    call(methodsToCall, callback) {
        const isArray = Array.isArray(methodsToCall);
        if (!isArray) {
            methodsToCall = [methodsToCall];
        }
        async.map(methodsToCall, (methodToCall, innerCallback) => {
            const callMethodRequest = new node_opcua_service_call_1.CallMethodRequest(methodToCall);
            (0, call_helpers_1.callMethodHelper)(this.context, this.addressSpace, callMethodRequest, (err, result) => {
                let callMethodResult;
                if (err) {
                    errorLog("Internal Error = ", err);
                    callMethodResult = new node_opcua_service_call_1.CallMethodResult({
                        statusCode: node_opcua_status_code_1.StatusCodes.BadInternalError
                    });
                }
                else {
                    callMethodResult = new node_opcua_service_call_1.CallMethodResult(result);
                }
                innerCallback(null, callMethodResult);
            });
        }, (err, callMethodResults) => {
            callback(null, isArray ? callMethodResults : callMethodResults[0]);
        });
    }
    getArgumentDefinition(methodId, callback) {
        return (0, node_opcua_pseudo_session_1.getArgumentDefinitionHelper)(this, methodId, callback);
    }
    translateBrowsePath(browsePaths, callback) {
        const isArray = Array.isArray(browsePaths);
        if (!isArray) {
            browsePaths = [browsePaths];
        }
        const browsePathResults = browsePaths.map((browsePath) => {
            return this.addressSpace.browsePath(browsePath);
        });
        callback(null, isArray ? browsePathResults : browsePathResults[0]);
    }
    write(nodesToWrite, callback) {
        const isArray = nodesToWrite instanceof Array;
        const _nodesToWrite = !isArray ? [nodesToWrite] : nodesToWrite;
        const context = this.context;
        setImmediate(() => {
            const statusCodesPromises = _nodesToWrite.map((nodeToWrite) => {
                (0, node_opcua_assert_1.assert)(!!nodeToWrite.nodeId, "expecting a nodeId");
                (0, node_opcua_assert_1.assert)(!!nodeToWrite.attributeId, "expecting a attributeId");
                const nodeId = nodeToWrite.nodeId;
                const obj = this.addressSpace.findNode(nodeId);
                if (!obj) {
                    return node_opcua_status_code_1.StatusCodes.BadNodeIdUnknown;
                }
                return (0, util_1.promisify)(obj.writeAttribute).call(obj, context, nodeToWrite);
            });
            Promise.all(statusCodesPromises).then((statusCodes) => {
                callback(null, isArray ? statusCodes : statusCodes[0]);
            });
        });
    }
}
exports.PseudoSession = PseudoSession;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
PseudoSession.prototype.read = thenify.withCallback(PseudoSession.prototype.read);
PseudoSession.prototype.write = thenify.withCallback(PseudoSession.prototype.write);
PseudoSession.prototype.browse = thenify.withCallback(PseudoSession.prototype.browse);
PseudoSession.prototype.browseNext = thenify.withCallback(PseudoSession.prototype.browseNext);
PseudoSession.prototype.getArgumentDefinition = thenify.withCallback(PseudoSession.prototype.getArgumentDefinition);
PseudoSession.prototype.call = thenify.withCallback(PseudoSession.prototype.call);
PseudoSession.prototype.translateBrowsePath = thenify.withCallback(PseudoSession.prototype.translateBrowsePath);
//# sourceMappingURL=pseudo_session.js.map