"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPartialData = exports._bindExtensionObject = exports._installExtensionObjectBindingOnProperties = exports.setExtensionObjectValue = exports._setExtensionObject = exports.propagateTouchValueUpward = exports._touchValue = void 0;
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_date_time_1 = require("node-opcua-date-time");
const node_opcua_data_value_1 = require("node-opcua-data-value");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_utils_1 = require("node-opcua-utils");
const node_opcua_variant_1 = require("node-opcua-variant");
const base_node_private_1 = require("./base_node_private");
const ua_variable_impl_1 = require("./ua_variable_impl");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
// const doDebug = true; // checkDebugFlag(__filename);
// const debugLog = make_warningLog(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
function w(str, n) {
    return str.padEnd(n).substring(n);
}
function isProxy(ext) {
    return ext.$isProxy ? true : false;
}
function getProxyTarget(ext) {
    (0, node_opcua_assert_1.default)(isProxy(ext));
    return ext.$proxyTarget;
}
function unProxy(ext) {
    return isProxy(ext) ? getProxyTarget(ext) : ext;
}
function _extensionObjectFieldGetter(target, key /*, receiver*/) {
    if (key === "$isProxy") {
        return true;
    }
    if (key === "$proxyTarget") {
        return target;
    }
    if (target[key] === undefined) {
        return undefined;
    }
    return target[key];
}
function _extensionObjectFieldSetter(variable, target, key, value /*, receiver*/) {
    target[key] = value;
    const child = variable[key];
    if (child && child.touchValue) {
        child.touchValue();
    }
    return true; // true means the set operation has succeeded
}
function makeHandler(variable) {
    const handler = {
        get: _extensionObjectFieldGetter,
        set: _extensionObjectFieldSetter.bind(null, variable)
    };
    return handler;
}
/**
 * inconditionnaly change the time stamp of the variable
 * if the variable is being listened to, and if the minimumSamplingInterval is exactly zero,
 * then the change will be reported to the observer
 *
 */
function _touchValue(property, now) {
    property.$dataValue.sourceTimestamp = now.timestamp;
    property.$dataValue.sourcePicoseconds = now.picoseconds;
    property.$dataValue.serverTimestamp = now.timestamp;
    property.$dataValue.serverPicoseconds = now.picoseconds;
    property.$dataValue.statusCode = node_opcua_status_code_1.StatusCodes.Good;
    if (property.minimumSamplingInterval === 0) {
        if (property.listenerCount("value_changed") > 0) {
            const clonedDataValue = property.readValue();
            property.emit("value_changed", clonedDataValue);
        }
    }
}
exports._touchValue = _touchValue;
function propagateTouchValueUpward(self, now) {
    _touchValue(self, now);
    if (self.parent && self.parent.nodeClass === node_opcua_data_model_1.NodeClass.Variable) {
        const parentVar = self.parent;
        if (!parentVar.isExtensionObject())
            return;
        propagateTouchValueUpward(parentVar, now);
    }
}
exports.propagateTouchValueUpward = propagateTouchValueUpward;
function propagateTouchValueDownward(self, now) {
    if (!self.isExtensionObject())
        return;
    // also propagate changes to embeded variables
    const dataTypeNode = self.getDataTypeNode();
    const definition = dataTypeNode.getStructureDefinition();
    for (const field of definition.fields || []) {
        const property = self.getChildByName(field.name);
        if (property) {
            _touchValue(property, now);
            // to do cascade recursivelly ?
        }
    }
}
function _setExtensionObject(self, ext) {
    // assert(!(ext as any).$isProxy, "internal error ! ExtensionObject has already been proxied !");
    if (Array.isArray(ext)) {
        (0, node_opcua_assert_1.default)(self.valueRank === 1, "Only Array is supported for the time being");
        ext = ext.map((e) => unProxy(e));
        self.$dataValue.value.arrayType = node_opcua_variant_1.VariantArrayType.Array;
        self.$extensionObject = ext.map((e) => new Proxy(e, makeHandler(self)));
        self.$dataValue.value.dataType = node_opcua_variant_1.DataType.ExtensionObject;
        self.$dataValue.value.value = self.$extensionObject;
        self.$dataValue.statusCode = node_opcua_status_code_1.StatusCodes.Good;
        return;
    }
    else {
        ext = unProxy(ext);
        self.$extensionObject = new Proxy(ext, makeHandler(self));
        self.$dataValue.value.dataType = node_opcua_variant_1.DataType.ExtensionObject;
        self.$dataValue.value.value = self.$extensionObject;
        self.$dataValue.statusCode = node_opcua_status_code_1.StatusCodes.Good;
    }
    const now = (0, node_opcua_date_time_1.getCurrentClock)();
    propagateTouchValueUpward(self, now);
    propagateTouchValueDownward(self, now);
}
exports._setExtensionObject = _setExtensionObject;
function setExtensionObjectValue(node, partialObject) {
    const extensionObject = node.$extensionObject;
    if (!extensionObject) {
        throw new Error("setExtensionObjectValue node has no extension object " + node.browseName.toString());
    }
    function _update_extension_object(extObject, partialObject1) {
        const keys = Object.keys(partialObject1);
        for (const prop of keys) {
            if (extObject[prop] instanceof Object) {
                _update_extension_object(extObject[prop], partialObject1[prop]);
            }
            else {
                extObject[prop] = partialObject1[prop];
            }
        }
    }
    _update_extension_object(extensionObject, partialObject);
}
exports.setExtensionObjectValue = setExtensionObjectValue;
function getOrCreateProperty(variableNode, field, options) {
    const dt = variableNode.getDataTypeNode();
    // the namespace for the structure browse name elements
    const structureNamespace = dt.nodeId.namespace;
    const components = variableNode.getComponents();
    let property;
    const selectedComponents = components.filter((f) => f instanceof ua_variable_impl_1.UAVariableImpl && f.browseName.name.toString() === field.name);
    // istanbul ignore next
    if (field.dataType.value === node_opcua_variant_1.DataType.Variant) {
        warningLog("Warning : variant is not supported in ExtensionObject");
    }
    if (selectedComponents.length === 1) {
        property = selectedComponents[0];
        /* istanbul ignore next */
    }
    else {
        if (!options.createMissingProp) {
            return null;
        }
        debugLog("adding missing array variable", field.name, variableNode.browseName.toString(), variableNode.nodeId.toString());
        // todo: Handle array appropriately...
        (0, node_opcua_assert_1.default)(selectedComponents.length === 0);
        // create a variable (Note we may use ns=1;s=parentName/0:PropertyName)
        property = variableNode.namespace.addVariable({
            browseName: { namespaceIndex: structureNamespace, name: field.name.toString() },
            componentOf: variableNode,
            dataType: field.dataType,
            minimumSamplingInterval: variableNode.minimumSamplingInterval
        });
        (0, node_opcua_assert_1.default)(property.minimumSamplingInterval === variableNode.minimumSamplingInterval);
    }
    return property;
}
function prepareVariantValue(dataType, value) {
    if ((dataType === node_opcua_variant_1.DataType.Int32 || dataType === node_opcua_variant_1.DataType.UInt32) && value && value.key) {
        value = value.value;
    }
    return value;
}
function bindProperty(variableNode, propertyNode, name, dataType) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    propertyNode.bindVariable({
        timestamped_get: () => {
            const propertyValue = variableNode.$extensionObject[name];
            if (propertyValue === undefined) {
                propertyNode.$dataValue.value.dataType = node_opcua_variant_1.DataType.Null;
                propertyNode.$dataValue.statusCode = node_opcua_status_code_1.StatusCodes.Good;
                propertyNode.$dataValue.value.value = null;
                return new node_opcua_data_value_1.DataValue(propertyNode.$dataValue);
            }
            const value = prepareVariantValue(dataType, propertyValue);
            propertyNode.$dataValue.statusCode = node_opcua_status_code_1.StatusCodes.Good;
            propertyNode.$dataValue.value.dataType = dataType;
            propertyNode.$dataValue.value.value = value;
            return new node_opcua_data_value_1.DataValue(propertyNode.$dataValue);
        },
        timestamped_set: (_dataValue, callback) => {
            callback(null, node_opcua_status_code_1.StatusCodes.BadNotWritable);
        }
    }, true);
}
function _installExtensionObjectBindingOnProperties(variableNode, options) {
    const addressSpace = variableNode.addressSpace;
    const dt = variableNode.getDataTypeNode();
    const definition = dt.getStructureDefinition();
    for (const field of definition.fields || []) {
        // istanbul ignore next
        if (node_opcua_nodeid_1.NodeId.sameNodeId(node_opcua_nodeid_1.NodeId.nullNodeId, field.dataType)) {
            warningLog("field.dataType is null ! ", field.name, node_opcua_nodeid_1.NodeId.nullNodeId.toString());
            warningLog(field.toString());
            warningLog(" dataType replaced with BaseDataType ");
            warningLog(definition.toString());
            field.dataType = variableNode.resolveNodeId("BaseDataType");
        }
        const propertyNode = getOrCreateProperty(variableNode, field, options);
        if (!propertyNode) {
            continue;
        }
        propertyNode.$dataValue.statusCode = node_opcua_status_code_1.StatusCodes.Good;
        propertyNode.touchValue();
        const basicDataType = addressSpace.findCorrespondingBasicDataType(field.dataType);
        // istanbul ignore next
        if (doDebug) {
            const x = addressSpace.findNode(field.dataType).browseName.toString();
            debugLog(chalk.cyan("xxx"), " dataType", w(field.dataType.toString(), 8), w(field.name, 25), "valueRank", chalk.cyan(w((0, base_node_private_1.valueRankToString)(field.valueRank), 10)), chalk.green(w(x, 15)), "basicType = ", chalk.yellow(w(basicDataType.toString(), 20)), propertyNode.nodeId.toString(), propertyNode.readValue().statusCode.toString());
        }
        const camelCaseName = (0, node_opcua_utils_1.lowerFirstLetter)(field.name);
        (0, node_opcua_assert_1.default)(Object.prototype.hasOwnProperty.call(variableNode.$extensionObject, camelCaseName));
        if (variableNode.$extensionObject[camelCaseName] !== undefined && basicDataType === node_opcua_variant_1.DataType.ExtensionObject) {
            propertyNode.bindExtensionObject(variableNode.$extensionObject[camelCaseName], Object.assign(Object.assign({}, options), { force: true }));
            // replace upwards
            variableNode.$extensionObject[camelCaseName] = propertyNode.$extensionObject;
        }
        else {
            const prop = variableNode.$extensionObject[camelCaseName];
            if (prop === undefined) {
                propertyNode._internal_set_value(new node_opcua_variant_1.Variant({
                    dataType: node_opcua_variant_1.DataType.Null
                }));
            }
            else {
                const preparedValue = prepareVariantValue(basicDataType, prop);
                propertyNode._internal_set_value(new node_opcua_variant_1.Variant({
                    dataType: basicDataType,
                    value: preparedValue
                }));
            }
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            //  property.camelCaseName = camelCaseName;
            propertyNode.setValueFromSource = function (variant) {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const inner_this = this;
                const variant1 = node_opcua_variant_1.Variant.coerce(variant);
                inner_this.verifyVariantCompatibility(variant1);
                // because self.$extensionObject is a Proxy with handlers that
                // cascade the chagne we do not need to call touchValue() here
                variableNode.$extensionObject[camelCaseName] = variant1.value;
            };
        }
        (0, node_opcua_assert_1.default)(propertyNode.readValue().statusCode.equals(node_opcua_status_code_1.StatusCodes.Good));
        bindProperty(variableNode, propertyNode, camelCaseName, basicDataType);
    }
}
exports._installExtensionObjectBindingOnProperties = _installExtensionObjectBindingOnProperties;
// eslint-disable-next-line complexity
function _bindExtensionObject(self, optionalExtensionObject, options) {
    var _a, _b;
    options = options || { createMissingProp: false };
    const addressSpace = self.addressSpace;
    const structure = addressSpace.findDataType("Structure");
    let extensionObject_;
    if (!structure) {
        // the addressSpace is limited and doesn't provide extension object
        // bindExtensionObject cannot be performed and shall finish here.
        return null;
    }
    (0, node_opcua_assert_1.default)(structure.browseName.toString() === "Structure", "expecting DataType Structure to be in IAddressSpace");
    const dt = self.getDataTypeNode();
    if (!dt.isSupertypeOf(structure)) {
        return null;
    }
    if (self.valueRank !== -1 && self.valueRank !== 1) {
        throw new Error("Cannot bind an extension object here, valueRank must be scalar (-1) or one-dimensional (1)");
    }
    // istanbul ignore next
    if (doDebug) {
        debugLog(" ------------------------------ binding ", self.browseName.toString(), self.nodeId.toString());
    }
    // ignore bindExtensionObject on sub extension object, bindExtensionObject has to be called from the top most object
    if (!options.force &&
        self.parent &&
        (self.parent.nodeClass === node_opcua_data_model_1.NodeClass.Variable || self.parent.nodeClass === node_opcua_data_model_1.NodeClass.VariableType)) {
        const parentDataType = self.parent.dataType;
        const dataTypeNode = addressSpace.findNode(parentDataType);
        // istanbul ignore next
        if (dataTypeNode && dataTypeNode.isSupertypeOf(structure)) {
            // warningLog(
            //     "Ignoring bindExtensionObject on sub extension object",
            //     "child=",
            //     self.browseName.toString(),
            //     "parent=",
            //     self.parent.browseName.toString()
            // );
            return null;
        }
    }
    // -------------------- make sure we do not bind a variable twice ....
    if (self.$extensionObject && !optionalExtensionObject) {
        // istanbul ignore next
        if (!self.checkExtensionObjectIsCorrect(self.$extensionObject)) {
            warningLog("on node : ", self.browseName.toString(), self.nodeId.toString(), "dataType=", self.dataType.toString({ addressSpace: self.addressSpace }));
            warningLog((_a = self.$extensionObject) === null || _a === void 0 ? void 0 : _a.toString());
            throw new Error("bindExtensionObject: $extensionObject is incorrect: we are expecting a " +
                self.dataType.toString({ addressSpace: self.addressSpace }) +
                " but we got a " +
                ((_b = self.$extensionObject) === null || _b === void 0 ? void 0 : _b.constructor.name));
        }
        return self.$extensionObject;
        // throw new Error("Variable already bound");
    }
    // ------------------------------------------------------
    // make sure we have a structure
    // ------------------------------------------------------
    const s = self.readValue();
    // istanbul ignore next
    if (self.dataTypeObj.isAbstract) {
        warningLog("Warning the DataType associated with this Variable is abstract ", self.dataTypeObj.browseName.toString());
        warningLog("You need to provide a extension object yourself ");
        throw new Error("bindExtensionObject requires a extensionObject as associated dataType is only abstract");
    }
    if (s.value && s.value.dataType === node_opcua_variant_1.DataType.ExtensionObject && s.value.value && optionalExtensionObject) {
        // we want to replace the extension object
        s.value.value = null;
    }
    innerBindExtensionObject();
    (0, node_opcua_assert_1.default)(self.$extensionObject instanceof Object);
    return self.$extensionObject;
    function innerBindExtensionObject() {
        if (s.value && (s.value.dataType === node_opcua_variant_1.DataType.Null || (s.value.dataType === node_opcua_variant_1.DataType.ExtensionObject && !s.value.value))) {
            if (self.valueRank === -1 /** Scalar */) {
                // create a structure and bind it
                extensionObject_ = optionalExtensionObject || addressSpace.constructExtensionObject(self.dataType, {});
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                self.bindVariable({
                    timestamped_get() {
                        const d = new node_opcua_data_value_1.DataValue(self.$dataValue);
                        d.value.value = self.$extensionObject ? self.$extensionObject.clone() : null;
                        return d;
                    },
                    timestamped_set(dataValue, callback) {
                        const ext = dataValue.value.value;
                        if (!self.checkExtensionObjectIsCorrect(ext)) {
                            return callback(null, node_opcua_status_code_1.StatusCodes.BadInvalidArgument);
                        }
                        _setExtensionObject(self, ext);
                        callback(null, node_opcua_status_code_1.StatusCodes.Good);
                    }
                }, true);
                _setExtensionObject(self, extensionObject_);
            }
            else if (self.valueRank === 1 /** Array */) {
                // create a structure and bind it
                extensionObject_ = optionalExtensionObject || [];
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                self.bindVariable({
                    timestamped_get() {
                        const d = new node_opcua_data_value_1.DataValue(self.$dataValue);
                        d.value.value = self.$extensionObject
                            ? self.$extensionObject.map((e) => e.clone())
                            : null;
                        return d;
                    },
                    timestamped_set(dataValue, callback) {
                        const ext = dataValue.value.value;
                        if (!self.checkExtensionObjectIsCorrect(ext)) {
                            return callback(null, node_opcua_status_code_1.StatusCodes.BadInvalidArgument);
                        }
                        _setExtensionObject(self, ext);
                        callback(null, node_opcua_status_code_1.StatusCodes.Good);
                    }
                }, true);
                _setExtensionObject(self, extensionObject_);
            }
            else {
                errorLog(self.toString());
                errorLog("Unsupported case ! valueRank= ", self.valueRank);
            }
        }
        else {
            // verify that variant has the correct type
            (0, node_opcua_assert_1.default)(s.value.dataType === node_opcua_variant_1.DataType.ExtensionObject);
            self.$extensionObject = s.value.value;
            (0, node_opcua_assert_1.default)(self.checkExtensionObjectIsCorrect(self.$extensionObject));
            (0, node_opcua_assert_1.default)(s.statusCode.equals(node_opcua_status_code_1.StatusCodes.Good));
        }
        _installExtensionObjectBindingOnProperties(self, options);
    }
}
exports._bindExtensionObject = _bindExtensionObject;
function extractPartialData(path, extensionObject) {
    let name;
    if (typeof path === "string") {
        path = path.split(".");
    }
    (0, node_opcua_assert_1.default)(path instanceof Array);
    let i;
    // read partial value
    const partialData = {};
    let p = partialData;
    for (i = 0; i < path.length - 1; i++) {
        name = path[i];
        p[name] = {};
        p = p[name];
    }
    name = path[path.length - 1];
    p[name] = 0;
    let c1 = partialData;
    let c2 = extensionObject;
    for (i = 0; i < path.length - 1; i++) {
        name = path[i];
        c1 = partialData[name];
        c2 = extensionObject[name];
    }
    name = path[path.length - 1];
    c1[name] = c2[name];
    c1[name] += 1;
    return partialData;
}
exports.extractPartialData = extractPartialData;
//# sourceMappingURL=ua_variable_impl_ext_obj.js.map