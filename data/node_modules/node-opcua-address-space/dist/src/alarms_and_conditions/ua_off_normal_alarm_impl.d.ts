import { DataValue } from "node-opcua-data-value";
import { NodeId } from "node-opcua-nodeid";
import { UAOffNormalAlarm_Base } from "node-opcua-nodeset-ua";
import { INamespace, UAVariable } from "../../source";
import { UADiscreteAlarmEx, UADiscreteAlarmImpl } from "./ua_discrete_alarm_impl";
export declare interface UAOffNormalAlarmEx extends Omit<UAOffNormalAlarm_Base, "ackedState" | "activeState" | "confirmedState" | "enabledState" | "latchedState" | "outOfServiceState" | "shelvingState" | "silenceState" | "suppressedState">, UADiscreteAlarmEx {
    getNormalStateNode(): UAVariable;
    getNormalStateValue(): any;
    setNormalStateValue(value: any): void;
}
export declare interface UAOffNormalAlarmImpl extends UAOffNormalAlarmEx, UADiscreteAlarmImpl {
    on(eventName: string, eventHandler: any): this;
}
/**
 * The OffNormalAlarmType is a specialization of the DiscreteAlarmType intended to represent a
 * discrete Condition that is considered to be not normal.
 * This sub type is usually used to indicate that a discrete value is in an Alarm state, it is active as
 * long as a non-normal value is present.
 */
export declare class UAOffNormalAlarmImpl extends UADiscreteAlarmImpl implements UAOffNormalAlarmEx {
    /**
     * When the value of inputNode doesn't match the normalState node value, then the alarm is raised.
     *
     */
    static instantiate(namespace: INamespace, limitAlarmTypeId: string | NodeId, options: any, data: any): UAOffNormalAlarmImpl;
    getNormalStateNode(): UAVariable;
    /**
     * @method getNormalStateValue
     */
    getNormalStateValue(): any;
    /**
     * @method setNormalStateValue
     * @param value
     */
    setNormalStateValue(value: any): void;
    _updateAlarmState(normalStateValue?: any, inputValue?: any): void;
    _onInputDataValueChange(dataValue: DataValue): void;
    protected _onNormalStateDataValueChange(dataValue: DataValue): void;
}
