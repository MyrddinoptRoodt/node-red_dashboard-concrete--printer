import { DataValue } from "node-opcua-data-value";
import { NodeId } from "node-opcua-nodeid";
import { UAAlarmCondition_Base } from "node-opcua-nodeset-ua";
import { BaseNode, INamespace, UAEventType, UAVariable } from "../../source";
import { UAShelvedStateMachineEx } from "../state_machine/ua_shelving_state_machine_ex";
import { UATwoStateVariableEx } from "../../source/ua_two_state_variable_ex";
import { ConditionInfo } from "./condition_info";
import { UAAcknowledgeableConditionEx, UAAcknowledgeableConditionHelper, UAAcknowledgeableConditionImpl } from "./ua_acknowledgeable_condition_impl";
export interface UAAlarmConditionHelper extends UAAcknowledgeableConditionHelper {
    activateAlarm(): void;
    deactivateAlarm(): void;
    isSuppressedOrShelved(): boolean;
    getSuppressedOrShelved(): boolean;
    setMaxTimeShelved(duration: number): void;
    getMaxTimeShelved(): number;
    getInputNodeNode(): UAVariable | null;
    getInputNodeValue(): any | null;
    updateState(): void;
    getCurrentConditionInfo(): ConditionInfo;
    installInputNodeMonitoring(inputNode: BaseNode | NodeId): void;
}
export declare interface UAAlarmConditionEx extends UAAlarmConditionHelper, UAAlarmCondition_Base, UAAcknowledgeableConditionEx {
    on(eventName: string, eventHandler: any): this;
    enabledState: UATwoStateVariableEx;
    activeState: UATwoStateVariableEx;
    ackedState: UATwoStateVariableEx;
    confirmedState?: UATwoStateVariableEx;
    suppressedState?: UATwoStateVariableEx;
    outOfServiceState?: UATwoStateVariableEx;
    shelvingState?: UAShelvedStateMachineEx;
    silenceState?: UATwoStateVariableEx;
    latchedState?: UATwoStateVariableEx;
}
export declare interface UAAlarmConditionImpl extends UAAlarmConditionEx, UAAcknowledgeableConditionImpl {
    on(eventName: string, eventHandler: any): this;
}
export declare class UAAlarmConditionImpl extends UAAcknowledgeableConditionImpl implements UAAlarmConditionEx {
    static MaxDuration: number;
    static instantiate(namespace: INamespace, alarmConditionTypeId: UAEventType | string | NodeId, options: any, data: any): UAAlarmConditionImpl;
    dispose(): void;
    activateAlarm(): void;
    deactivateAlarm(): void;
    /**
     * @deprecated use deactivateAlarm instead (with no s after de-activate)
     */
    desactivateAlarm(): void;
    isSuppressedOrShelved(): boolean;
    getSuppressedOrShelved(): boolean;
    /**
     *
     * note: duration must be greater than 10ms and lesser than 2**31 ms
     */
    setMaxTimeShelved(duration: number): void;
    /**
     * note: return a  Duration
     */
    getMaxTimeShelved(): number;
    /**
     * @method getInputNodeNode
     * @return {BaseNode} return the node in the address space pointed by the inputNode value
     *
     * Note: please note the difference between alarm.inputNode
     *    *  alarm.inputNode is a UAVariable property of the alarm object holding the nodeid of the input
     *       node in its value.
     *    *  getInputNodeNode() is the UAVariable that contains the value that affects the state of the alarm and
     *       whose node id is stored in alarm.inputNode
     */
    getInputNodeNode(): UAVariable | null;
    /**
     * @method getInputNodeValue
     * @return {*}
     */
    getInputNodeValue(): any | null;
    updateState(): void;
    _onInputDataValueChange(newValue: DataValue): void;
    /**
     * @method installInputNodeMonitoring
     * install mechanism that listen to input node datavalue changes so that alarm status
     * can be automatically updated appropriatly.
     * @param inputNode {BaseNode}
     * @return {void}
     * @protected
     */
    installInputNodeMonitoring(inputNode: BaseNode | NodeId): void;
    getCurrentConditionInfo(): ConditionInfo;
    /***
     * @method  _calculateConditionInfo
     * @param stateData {Object}   the new calculated state of the alarm
     * @param isActive  {Boolean}
     * @param value     {Number}   the new value of the limit alarm
     * @param oldCondition  {ConditionInfo} given for information purpose
     * @param oldCondition.severity
     * @param oldCondition.quality
     * @param oldCondition.message
     * @param oldCondition.retain
     * @return {ConditionInfo} the new condition info
     *
     * this method need to be overridden by the instantiate to allow custom message and severity
     * to be set based on specific context of the alarm.
     *
     * @example
     *
     *
     *    var myAlarm = addressSpace.instantiateExclusiveLimitAlarm({...});
     *    myAlarm._calculateConditionInfo = function(stateName,value,oldCondition) {
     *       var percent = Math.ceil(value * 100);
     *       return new ConditionInfo({
     *            message: "Tank is almost " + percent + "% full",
     *            severity: 100,
     *            quality: StatusCodes.Good
     *      });
     *    };
     *
     */
    _calculateConditionInfo(stateData: string | null, isActive: boolean, value: string, oldCondition: ConditionInfo): ConditionInfo;
    _signalInitialCondition(): void;
    _signalNewCondition(stateName: string | null, isActive?: boolean, value?: string): void;
}
