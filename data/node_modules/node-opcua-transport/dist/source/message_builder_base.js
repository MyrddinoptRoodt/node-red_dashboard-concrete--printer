"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageBuilderBase = exports.readRawMessageHeader = void 0;
/**
 * @module node-opcua-transport
 */
const events_1 = require("events");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_binary_stream_1 = require("node-opcua-binary-stream");
const node_opcua_buffer_utils_1 = require("node-opcua-buffer-utils");
const node_opcua_chunkmanager_1 = require("node-opcua-chunkmanager");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_packet_assembler_1 = require("node-opcua-packet-assembler");
const node_opcua_utils_1 = require("node-opcua-utils");
const status_codes_1 = require("./status_codes");
const doPerfMonitoring = process.env.NODEOPCUADEBUG && process.env.NODEOPCUADEBUG.indexOf("PERF") >= 0;
const errorLog = (0, node_opcua_debug_1.make_errorLog)("MessageBuilder");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("MessageBuilder");
const warningLog = (0, node_opcua_debug_1.make_warningLog)("MessageBuilder");
function readRawMessageHeader(data) {
    const messageHeader = (0, node_opcua_chunkmanager_1.readMessageHeader)(new node_opcua_binary_stream_1.BinaryStream(data));
    return {
        extra: "",
        length: messageHeader.length,
        messageHeader
    };
}
exports.readRawMessageHeader = readRawMessageHeader;
/**
 * @class MessageBuilderBase
 * @extends EventEmitter
 * @uses PacketAssembler
 * @constructor
 * @param options {Object}
 * @param [options.signatureLength=0] {number}
 *
 */
class MessageBuilderBase extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.id = "";
        this._tick0 = 0;
        this._tick1 = 0;
        this._hasReceivedError = false;
        this.blocks = [];
        this.messageChunks = [];
        this._expectedChannelId = 0;
        options = options || {
            maxMessageSize: 0,
            maxChunkCount: 0,
            maxChunkSize: 0
        };
        this.signatureLength = options.signatureLength || 0;
        this.maxMessageSize = options.maxMessageSize || MessageBuilderBase.defaultMaxMessageSize;
        this.maxChunkCount = options.maxChunkCount || MessageBuilderBase.defaultMaxChunkCount;
        this.maxChunkSize = options.maxChunkSize || MessageBuilderBase.defaultMaxChunkSize;
        this.options = options;
        this._packetAssembler = new node_opcua_packet_assembler_1.PacketAssembler({
            minimumSizeInBytes: 8,
            maxChunkSize: this.maxChunkSize,
            readChunkFunc: readRawMessageHeader
        });
        this._packetAssembler.on("chunk", (messageChunk) => this._feed_messageChunk(messageChunk));
        this._packetAssembler.on("startChunk", (info, data) => {
            if (doPerfMonitoring) {
                // record tick 0: when the first data is received
                this._tick0 = (0, node_opcua_utils_1.get_clock_tick)();
            }
            /**
             *
             * notify the observers that a new message is being built
             * @event start_chunk
             * @param info
             * @param data
             */
            this.emit("startChunk", info, data);
        });
        this._packetAssembler.on("error", (err) => {
            warningLog("packet assembler ", err.message);
            return this._report_error(status_codes_1.StatusCodes2.BadTcpMessageTooLarge, "packet assembler: " + err.message);
        });
        this._securityDefeated = false;
        this.totalBodySize = 0;
        this.totalMessageSize = 0;
        this.channelId = 0;
        this.offsetBodyStart = 0;
        this.sequenceHeader = null;
        this._init_new();
    }
    dispose() {
        this.removeAllListeners();
    }
    /**
     * Feed message builder with some data
     * @method feed
     * @param data
     */
    feed(data) {
        if (!this._securityDefeated && !this._hasReceivedError) {
            this._packetAssembler.feed(data);
        }
    }
    _decodeMessageBody(fullMessageBody) {
        return true;
    }
    _read_headers(binaryStream) {
        try {
            this.messageHeader = (0, node_opcua_chunkmanager_1.readMessageHeader)(binaryStream);
            (0, node_opcua_assert_1.assert)(binaryStream.length === 8, "expecting message header to be 8 bytes");
            this.channelId = binaryStream.readUInt32();
            (0, node_opcua_assert_1.assert)(binaryStream.length === 12);
            // verifying secure ChannelId
            if (this._expectedChannelId && this.channelId !== this._expectedChannelId) {
                return this._report_error(status_codes_1.StatusCodes2.BadTcpSecureChannelUnknown, "Invalid secure channel Id");
            }
            return true;
        }
        catch (err) {
            return this._report_error(status_codes_1.StatusCodes2.BadTcpInternalError, "_read_headers error " + err.message);
        }
    }
    _report_error(statusCode, errorMessage) {
        this._hasReceivedError = true;
        /**
         * notify the observers that an error has occurred
         * @event error
         * @param error the error to raise
         */
        debugLog("Error  ", this.id, errorMessage);
        // xx errorLog(new Error());
        this.emit("error", new Error(errorMessage), statusCode, this.sequenceHeader ? this.sequenceHeader.requestId : null);
        return false;
    }
    _init_new() {
        this._securityDefeated = false;
        this._hasReceivedError = false;
        this.totalBodySize = 0;
        this.totalMessageSize = 0;
        this.blocks = [];
        this.messageChunks = [];
    }
    /**
     * append a message chunk
     * @method _append
     * @param chunk
     * @private
     */
    _append(chunk) {
        if (this._hasReceivedError) {
            // the message builder is in error mode and further message chunks should be discarded.
            return false;
        }
        if (this.messageChunks.length + 1 > this.maxChunkCount) {
            return this._report_error(status_codes_1.StatusCodes2.BadTcpMessageTooLarge, `max chunk count exceeded: ${this.maxChunkCount}`);
        }
        this.messageChunks.push(chunk);
        this.totalMessageSize += chunk.length;
        if (this.totalMessageSize > this.maxMessageSize) {
            return this._report_error(status_codes_1.StatusCodes2.BadTcpMessageTooLarge, `max message size exceeded: ${this.maxMessageSize}`);
        }
        const binaryStream = new node_opcua_binary_stream_1.BinaryStream(chunk);
        if (!this._read_headers(binaryStream)) {
            return this._report_error(status_codes_1.StatusCodes2.BadTcpInternalError, `Invalid message header detected`);
        }
        (0, node_opcua_assert_1.assert)(binaryStream.length >= 12);
        // verify message chunk length
        if (this.messageHeader.length !== chunk.length) {
            // tslint:disable:max-line-length
            return this._report_error(status_codes_1.StatusCodes2.BadTcpInternalError, `Invalid messageChunk size: the provided chunk is ${chunk.length} bytes long but header specifies ${this.messageHeader.length}`);
        }
        // the start of the message body block
        const offsetBodyStart = binaryStream.length;
        // the end of the message body block
        const offsetBodyEnd = binaryStream.buffer.length;
        this.totalBodySize += offsetBodyEnd - offsetBodyStart;
        this.offsetBodyStart = offsetBodyStart;
        // add message body to a queue
        // note : Buffer.slice create a shared memory !
        //        use Buffer.clone
        const sharedBuffer = chunk.slice(this.offsetBodyStart, offsetBodyEnd);
        const clonedBuffer = (0, node_opcua_buffer_utils_1.createFastUninitializedBuffer)(sharedBuffer.length);
        sharedBuffer.copy(clonedBuffer, 0, 0);
        this.blocks.push(clonedBuffer);
        return true;
    }
    _feed_messageChunk(chunk) {
        (0, node_opcua_assert_1.assert)(chunk);
        const messageHeader = (0, node_opcua_chunkmanager_1.readMessageHeader)(new node_opcua_binary_stream_1.BinaryStream(chunk));
        /**
         * notify the observers that new message chunk has been received
         * @event chunk
         * @param messageChunk the raw message chunk
         */
        this.emit("chunk", chunk);
        if (messageHeader.isFinal === "F") {
            // last message
            this._append(chunk);
            if (this._hasReceivedError) {
                return false;
            }
            const fullMessageBody = this.blocks.length === 1 ? this.blocks[0] : Buffer.concat(this.blocks);
            if (doPerfMonitoring) {
                // record tick 1: when a complete message has been received ( all chunks assembled)
                this._tick1 = (0, node_opcua_utils_1.get_clock_tick)();
            }
            /**
             * notify the observers that a full message has been received
             * @event full_message_body
             * @param full_message_body the full message body made of all concatenated chunks.
             */
            this.emit("full_message_body", fullMessageBody);
            this._decodeMessageBody(fullMessageBody);
            // be ready for next block
            this._init_new();
            return true;
        }
        else if (messageHeader.isFinal === "A") {
            return this._report_error(status_codes_1.StatusCodes2.BadRequestInterrupted, "received and Abort Message");
        }
        else if (messageHeader.isFinal === "C") {
            return this._append(chunk);
        }
        return false;
    }
}
exports.MessageBuilderBase = MessageBuilderBase;
MessageBuilderBase.defaultMaxChunkCount = 1000;
MessageBuilderBase.defaultMaxMessageSize = 1024 * 64;
MessageBuilderBase.defaultMaxChunkSize = 1024 * 8;
//# sourceMappingURL=message_builder_base.js.map