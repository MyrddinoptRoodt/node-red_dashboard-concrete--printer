"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TCP_transport = exports.getFakeTransport = exports.setFakeTransport = void 0;
/**
 * @module node-opcua-transport
 */
const events_1 = require("events");
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_object_registry_1 = require("node-opcua-object-registry");
const node_opcua_packet_assembler_1 = require("node-opcua-packet-assembler");
const status_codes_1 = require("./status_codes");
const message_builder_base_1 = require("./message_builder_base");
const utils_1 = require("./utils");
const TCPErrorMessage_1 = require("./TCPErrorMessage");
const tools_1 = require("./tools");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
let fakeSocket = {
    invalid: true,
    destroy() {
        errorLog("MockSocket.destroy");
    },
    end() {
        errorLog("MockSocket.end");
    }
};
function setFakeTransport(mockSocket) {
    fakeSocket = mockSocket;
}
exports.setFakeTransport = setFakeTransport;
function getFakeTransport() {
    if (fakeSocket.invalid) {
        throw new Error("getFakeTransport: setFakeTransport must be called first  - BadProtocolVersionUnsupported");
    }
    return fakeSocket;
}
exports.getFakeTransport = getFakeTransport;
let counter = 0;
// tslint:disable:class-name
class TCP_transport extends events_1.EventEmitter {
    constructor() {
        super();
        this.name = this.constructor.name + counter;
        counter += 1;
        this._timerId = null;
        this._timeout = 30000; // 30 seconds timeout
        this._socket = null;
        this.headerSize = 8;
        this.maxMessageSize = 0;
        this.maxChunkCount = 0;
        this.receiveBufferSize = 0;
        this.sendBufferSize = 0;
        this.protocolVersion = 0;
        this._disconnecting = false;
        this.bytesWritten = 0;
        this.bytesRead = 0;
        this._theCallback = undefined;
        this.chunkWrittenCount = 0;
        this.chunkReadCount = 0;
        this._onSocketClosedHasBeenCalled = false;
        this._onSocketEndedHasBeenCalled = false;
        TCP_transport.registry.register(this);
    }
    setLimits({ receiveBufferSize, sendBufferSize, maxMessageSize, maxChunkCount }) {
        this.receiveBufferSize = receiveBufferSize;
        this.sendBufferSize = sendBufferSize;
        this.maxMessageSize = maxMessageSize;
        this.maxChunkCount = maxChunkCount;
        // reinstall packetAssembler with correct limits
        this._install_packetAssembler();
    }
    get timeout() {
        return this._timeout;
    }
    set timeout(value) {
        debugLog("Setting socket " + this.name + " timeout = ", value);
        this._timeout = value;
    }
    dispose() {
        this._cleanup_timers();
        (0, node_opcua_assert_1.assert)(!this._timerId);
        if (this._socket) {
            this._socket.destroy();
            this._socket.removeAllListeners();
            this._socket = null;
        }
        TCP_transport.registry.unregister(this);
    }
    /**
     * write the message_chunk on the socket.
     * @method write
     * @param messageChunk
     */
    write(messageChunk, callback) {
        const header = (0, message_builder_base_1.readRawMessageHeader)(messageChunk);
        (0, node_opcua_assert_1.assert)(header.length === messageChunk.length);
        const c = header.messageHeader.isFinal;
        (0, node_opcua_assert_1.assert)(c === "F" || c === "C" || c === "A");
        this._write_chunk(messageChunk, (err) => {
            callback && callback(err);
        });
    }
    get isDisconnecting() {
        return this._disconnecting;
    }
    /**
     * disconnect the TCP layer and close the underlying socket.
     * The ```"close"``` event will be emitted to the observers with err=null.
     *
     * @method disconnect
     * @async
     * @param callback
     */
    disconnect(callback) {
        (0, node_opcua_assert_1.assert)(typeof callback === "function", "expecting a callback function, but got " + callback);
        if (this._disconnecting) {
            callback();
            return;
        }
        (0, node_opcua_assert_1.assert)(!this._disconnecting, "TCP Transport has already been disconnected");
        this._disconnecting = true;
        // xx assert(!this._theCallback,
        //              "disconnect shall not be called while the 'one time message receiver' is in operation");
        this._cleanup_timers();
        if (this._socket) {
            this._socket.end();
            this._socket && this._socket.destroy();
            // xx this._socket.removeAllListeners();
            this._socket = null;
        }
        this.on_socket_ended(null);
        setImmediate(() => {
            callback();
        });
    }
    isValid() {
        return this._socket !== null && !this._socket.destroyed && !this._disconnecting;
    }
    _write_chunk(messageChunk, callback) {
        if (this._socket !== null) {
            this.bytesWritten += messageChunk.length;
            this.chunkWrittenCount++;
            this._socket.write(messageChunk, callback);
        }
        else {
            if (callback) {
                callback();
            }
        }
    }
    on_socket_ended(err) {
        (0, node_opcua_assert_1.assert)(!this._onSocketEndedHasBeenCalled);
        this._onSocketEndedHasBeenCalled = true; // we don't want to send close event twice ...
        /**
         * notify the observers that the transport layer has been disconnected.
         * @event close
         * @param err the Error object or null
         */
        this.emit("close", err || null);
    }
    _install_packetAssembler() {
        if (this.packetAssembler) {
            this.packetAssembler.removeAllListeners();
            this.packetAssembler = undefined;
        }
        // install packet assembler ...
        this.packetAssembler = new node_opcua_packet_assembler_1.PacketAssembler({
            readChunkFunc: message_builder_base_1.readRawMessageHeader,
            minimumSizeInBytes: this.headerSize,
            maxChunkSize: this.receiveBufferSize //Math.max(this.receiveBufferSize, this.sendBufferSize)
        });
        this.packetAssembler.on("chunk", (chunk) => this._on_message_chunk_received(chunk));
        this.packetAssembler.on("error", (err, code) => {
            let statusCode = status_codes_1.StatusCodes2.BadTcpMessageTooLarge;
            switch (code) {
                case node_opcua_packet_assembler_1.PacketAssemblerErrorCode.ChunkSizeExceeded:
                    statusCode = status_codes_1.StatusCodes2.BadTcpMessageTooLarge;
                    break;
                default:
                    statusCode = status_codes_1.StatusCodes2.BadTcpInternalError;
            }
            this.sendErrorMessage(statusCode, err.message);
            this.prematureTerminate(new Error("Packet Assembler : " + err.message), statusCode);
        });
    }
    /**
     * @method _install_socket
     * @param socket {Socket}
     * @protected
     */
    _install_socket(socket) {
        (0, node_opcua_assert_1.assert)(socket);
        this._socket = socket;
        if (doDebug) {
            debugLog("  TCP_transport#_install_socket ", this.name);
        }
        this._install_packetAssembler();
        this._socket
            .on("data", (data) => this._on_socket_data(data))
            .on("close", (hadError) => this._on_socket_close(hadError))
            .on("end", (err) => this._on_socket_end(err))
            .on("error", (err) => this._on_socket_error(err));
        // set socket timeout
        debugLog("  TCP_transport#install => setting " + this.name + " _socket.setTimeout to ", this.timeout);
        // let use a large timeout here to make sure that we not conflict with our internal timeout
        this._socket.setTimeout(this.timeout + 2000, () => {
            debugLog(` _socket ${this.name} has timed out (timeout = ${this.timeout})`);
            this.prematureTerminate(new Error("socket timeout : timeout=" + this.timeout), status_codes_1.StatusCodes2.BadTimeout);
        });
    }
    sendErrorMessage(statusCode, extraErrorDescription) {
        // When the Client receives an Error Message it reports the error to the application and closes the TransportConnection gracefully.
        // If a Client encounters a fatal error, it shall report the error to the application and send a CloseSecureChannel Message.
        /* istanbul ignore next*/
        if (doDebug) {
            debugLog(chalk.red(" sendErrorMessage        ") + chalk.cyan(statusCode.toString()));
            debugLog(chalk.red(" extraErrorDescription   ") + chalk.cyan(extraErrorDescription));
        }
        const reason = `${statusCode.toString()}:${extraErrorDescription || ""}`;
        const errorResponse = new TCPErrorMessage_1.TCPErrorMessage({
            statusCode,
            reason
        });
        const messageChunk = (0, tools_1.packTcpMessage)("ERR", errorResponse);
        this.write(messageChunk);
    }
    prematureTerminate(err, statusCode) {
        // https://reference.opcfoundation.org/v104/Core/docs/Part6/6.7.3/
        debugLog("prematureTerminate", err ? err.message : "", statusCode.toString());
        if (this._socket) {
            err.message = "premature socket termination " + err.message;
            // we consider this as an error
            const _s = this._socket;
            _s.end();
            _s.destroy(); // new Error("Socket has timed out"));
            _s.emit("error", err);
            this._socket = null;
            this.dispose();
            _s.removeAllListeners();
        }
        // this.gracefullShutdown(err);
    }
    /**
     * @method _install_one_time_message_receiver
     *
     * install a one time message receiver callback
     *
     * Rules:
     * * TCP_transport will not emit the ```message``` event, while the "one time message receiver" is in operation.
     * * the TCP_transport will wait for the next complete message chunk and call the provided callback func
     *   ```callback(null,messageChunk);```
     *
     * if a messageChunk is not received within ```TCP_transport.timeout``` or if the underlying socket reports
     * an error, the callback function will be called with an Error.
     *
     */
    _install_one_time_message_receiver(callback) {
        (0, node_opcua_assert_1.assert)(!this._theCallback, "callback already set");
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        this._theCallback = callback;
        this._start_one_time_message_receiver();
    }
    _fulfill_pending_promises(err, data) {
        this._cleanup_timers();
        if (this._socket && this._on_error_during_one_time_message_receiver) {
            this._socket.removeListener("close", this._on_error_during_one_time_message_receiver);
            this._on_error_during_one_time_message_receiver = null;
        }
        const callback = this._theCallback;
        this._theCallback = undefined;
        if (callback) {
            callback(err, data);
            return true;
        }
        return false;
    }
    _on_message_chunk_received(messageChunk) {
        if (utils_1.doTraceIncomingChunk) {
            console.log((0, node_opcua_debug_1.hexDump)(messageChunk));
        }
        const hadCallback = this._fulfill_pending_promises(null, messageChunk);
        this.chunkReadCount++;
        if (!hadCallback) {
            /**
             * notify the observers that a message chunk has been received
             * @event message
             * @param message_chunk the message chunk
             */
            this.emit("chunk", messageChunk);
        }
    }
    _cleanup_timers() {
        if (this._timerId) {
            clearTimeout(this._timerId);
            this._timerId = null;
        }
    }
    _start_one_time_message_receiver() {
        (0, node_opcua_assert_1.assert)(!this._timerId, "timer already started");
        // Setup timeout detection timer ....
        this._timerId = setTimeout(() => {
            this._timerId = null;
            this._fulfill_pending_promises(new Error(`Timeout in waiting for data on socket ( timeout was = ${this.timeout} ms)`));
        }, this.timeout);
        // also monitored
        if (this._socket) {
            // to do = intercept socket error as well
            this._on_error_during_one_time_message_receiver = (err) => {
                this._fulfill_pending_promises(new Error(`ERROR in waiting for data on socket ( timeout was = ${this.timeout} ms) ` + (err === null || err === void 0 ? void 0 : err.message)));
            };
            this._socket.on("close", this._on_error_during_one_time_message_receiver);
        }
    }
    on_socket_closed(err) {
        if (this._onSocketClosedHasBeenCalled) {
            return;
        }
        (0, node_opcua_assert_1.assert)(!this._onSocketClosedHasBeenCalled);
        this._onSocketClosedHasBeenCalled = true; // we don't want to send close event twice ...
        /**
         * notify the observers that the transport layer has been disconnected.
         * @event socket_closed
         * @param err the Error object or null
         */
        this.emit("socket_closed", err || null);
    }
    _on_socket_data(data) {
        // istanbul ignore next
        if (!this.packetAssembler) {
            throw new Error("internal Error");
        }
        this.bytesRead += data.length;
        if (data.length > 0) {
            this.packetAssembler.feed(data);
        }
    }
    _on_socket_close(hadError) {
        // istanbul ignore next
        if (doDebug) {
            debugLog(chalk.red(" SOCKET CLOSE : "), chalk.yellow("had_error ="), chalk.cyan(hadError.toString()), this.name);
        }
        if (this._socket) {
            debugLog("  remote address = ", this._socket.remoteAddress, " ", this._socket.remoteFamily, " ", this._socket.remotePort);
        }
        if (hadError) {
            if (this._socket) {
                this._socket.destroy();
            }
        }
        const err = hadError ? new Error("ERROR IN SOCKET  " + hadError.toString()) : undefined;
        this.on_socket_closed(err);
        this.dispose();
    }
    _on_socket_ended_message(err) {
        if (this._disconnecting) {
            return;
        }
        debugLog(chalk.red("Transport Connection ended") + " " + this.name);
        (0, node_opcua_assert_1.assert)(!this._disconnecting);
        err = err || new Error("_socket has been disconnected by third party");
        this.on_socket_ended(err);
        this._disconnecting = true;
        debugLog(" bytesRead    = ", this.bytesRead);
        debugLog(" bytesWritten = ", this.bytesWritten);
        this._fulfill_pending_promises(new Error("Connection aborted - ended by server : " + (err ? err.message : "")));
    }
    _on_socket_end(err) {
        // istanbul ignore next
        if (doDebug) {
            debugLog(chalk.red(" SOCKET END : err="), chalk.yellow(err ? err.message : "null"), this.name);
        }
        this._on_socket_ended_message(err);
    }
    _on_socket_error(err) {
        // istanbul ignore next
        if (doDebug) {
            debugLog(chalk.red(" SOCKET ERROR : "), chalk.yellow(err.message), this.name);
        }
        // node The "close" event will be called directly following this event.
    }
}
exports.TCP_transport = TCP_transport;
TCP_transport.registry = new node_opcua_object_registry_1.ObjectRegistry();
//# sourceMappingURL=tcp_transport.js.map