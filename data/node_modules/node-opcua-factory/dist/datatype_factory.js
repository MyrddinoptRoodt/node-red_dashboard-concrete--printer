"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTypeFactory = exports._findFieldSchema = void 0;
/**
 * @module node-opcua-factory
 */
const util = require("util");
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_constants_1 = require("node-opcua-constants");
const builtin_types_1 = require("./builtin_types");
const enumerations_1 = require("./enumerations");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
function _findFieldSchema(typeDictionary, field, value) {
    const fieldType = field.fieldType;
    if (field.allowSubType && field.category === "complex") {
        const fieldTypeConstructor = value ? value.constructor : field.fieldTypeConstructor;
        const _newFieldSchema = fieldTypeConstructor.schema;
        return _newFieldSchema;
    }
    const fieldTypeConstructor = field.fieldTypeConstructor || typeDictionary.getStructureTypeConstructor(fieldType);
    return field.schema || fieldTypeConstructor.schema;
}
exports._findFieldSchema = _findFieldSchema;
class DataTypeFactory {
    constructor(baseDataFactories) {
        this.imports = [];
        this._structureTypeConstructorByNameMap = new Map();
        this._structureTypeConstructorByDataTypeMap = new Map();
        this._structureTypeConstructorByEncodingNodeIdMap = new Map();
        this._enumerations = new Map();
        this.defaultByteOrder = "LittleEndian";
        this.targetNamespace = "";
        this.baseDataFactories = baseDataFactories;
    }
    repairBaseDataFactories(baseDataFactories) {
        this.baseDataFactories = baseDataFactories;
    }
    hasBuiltInType(name) {
        return (0, builtin_types_1.hasBuiltInType)(name);
    }
    getBuiltInType(name) {
        return (0, builtin_types_1.getBuiltInType)(name);
    }
    getBuiltInTypeByDataType(nodeId) {
        return (0, builtin_types_1.getBuiltInType)(node_opcua_constants_1.DataTypeIds[nodeId.value]);
    }
    // -----------------------------
    // EnumerationDefinitionSchema
    registerEnumeration(enumeration) {
        (0, node_opcua_assert_1.assert)(!this._enumerations.has(enumeration.name), "enumeration already registered");
        this._enumerations.set(enumeration.name, enumeration);
    }
    hasEnumeration(enumName) {
        if (this._enumerations.has(enumName)) {
            return true;
        }
        for (const factory of this.baseDataFactories) {
            const e = factory.hasEnumeration(enumName);
            if (e) {
                return true;
            }
        }
        if ((0, enumerations_1.hasBuiltInEnumeration)(enumName)) {
            return true;
        }
        return false;
    }
    getEnumeration(enumName) {
        if (this._enumerations.has(enumName)) {
            return this._enumerations.get(enumName) || null;
        }
        for (const factory of this.baseDataFactories) {
            const hasEnum = factory.hasEnumeration(enumName);
            if (hasEnum) {
                const e = factory.getEnumeration(enumName);
                return e;
            }
        }
        const ee = (0, enumerations_1.getBuiltInEnumeration)(enumName);
        return ee;
    }
    //  ----------------------------
    findConstructorForDataType(dataTypeNodeId) {
        const constructor = this.getConstructorForDataType(dataTypeNodeId);
        if (constructor) {
            return constructor;
        }
        this.getConstructorForDataType(dataTypeNodeId);
        throw new Error("Cannot find StructureType constructor for dataType " + dataTypeNodeId.toString());
    }
    getConstructorForDataType(dataTypeNodeId) {
        const constructor = this._structureTypeConstructorByDataTypeMap.get(dataTypeNodeId.toString());
        if (constructor) {
            return constructor;
        }
        for (const factory of this.baseDataFactories) {
            const constructor2 = factory.getConstructorForDataType(dataTypeNodeId);
            if (constructor2) {
                return constructor2;
            }
        }
        return null;
    }
    // ----------------------------------------------------------------------------------------------------
    // Access by typeName
    // ----------------------------------------------------------------------------------------------------
    structuredTypesNames() {
        return this._structureTypeConstructorByNameMap.keys();
    }
    getStructureTypeConstructor(typeName) {
        const constructor = this._structureTypeConstructorByNameMap.get(typeName);
        if (constructor) {
            return constructor;
        }
        for (const factory of this.baseDataFactories) {
            if (!factory.hasStructuredType(typeName)) {
                continue;
            }
            const constructor2 = factory.getStructureTypeConstructor(typeName);
            if (constructor2) {
                return constructor2;
            }
        }
        // istanbul ignore next
        if (doDebug) {
            console.log([...this.structuredTypesNames()].join(" "));
        }
        // istanbul ignore next
        throw new Error("Cannot find StructureType constructor for " + typeName + " - it may be abstract, or it could be a basic type");
    }
    hasStructuredType(typeName) {
        if (this._structureTypeConstructorByNameMap.has(typeName)) {
            return true;
        }
        for (const factory of this.baseDataFactories) {
            if (factory.hasStructuredType(typeName)) {
                return true;
            }
        }
        return false;
    }
    getStructuredTypeSchema(typeName) {
        const constructor = this.getStructureTypeConstructor(typeName);
        return constructor.schema;
    }
    // istanbul ignore next
    dump() {
        console.log(" dumping registered factories");
        console.log(" Factory ", [...this.structuredTypesNames()].sort().forEach((e) => e));
        console.log(" done");
    }
    registerClassDefinition(dataTypeNodeId, className, classConstructor) {
        this._registerFactory(dataTypeNodeId, className, classConstructor);
        if (classConstructor.encodingDefaultBinary && classConstructor.encodingDefaultBinary.value !== 0) {
            this.associateWithBinaryEncoding(className, classConstructor.encodingDefaultBinary);
        }
        else {
            // for instance in DI FetchResultDataType should be abstract but is not
            debugLog("warning ", dataTypeNodeId.toString(), "name=", className, " do not have binary encoding");
        }
    }
    // ----------------------------------------------------------------------------------------------------
    // Access by binaryEncodingNodeId
    // ----------------------------------------------------------------------------------------------------
    getConstructor(binaryEncodingNodeId) {
        const expandedNodeIdKey = makeExpandedNodeIdKey(binaryEncodingNodeId);
        const constructor = this._structureTypeConstructorByEncodingNodeIdMap.get(expandedNodeIdKey);
        if (constructor) {
            return constructor;
        }
        for (const factory of this.baseDataFactories) {
            const constructor2 = factory.getConstructor(binaryEncodingNodeId);
            if (constructor2) {
                return constructor2;
            }
        }
        debugLog(chalk.red("#getConstructor : cannot find constructor for expandedId "), binaryEncodingNodeId.toString());
        return null;
    }
    hasConstructor(binaryEncodingNodeId) {
        if (!binaryEncodingNodeId) {
            return false;
        }
        /* istanbul ignore next */
        if (!verifyExpandedNodeId(binaryEncodingNodeId)) {
            console.log("Invalid expandedNodeId");
            return false;
        }
        const expandedNodeIdKey = makeExpandedNodeIdKey(binaryEncodingNodeId);
        const constructor = this._structureTypeConstructorByEncodingNodeIdMap.get(expandedNodeIdKey);
        if (constructor) {
            return true;
        }
        for (const factory of this.baseDataFactories) {
            const constructor2 = factory.getConstructor(binaryEncodingNodeId);
            if (constructor2) {
                return true;
            }
        }
        return false;
    }
    constructObject(binaryEncodingNodeId) {
        if (!verifyExpandedNodeId(binaryEncodingNodeId)) {
            throw new Error(" constructObject : invalid expandedNodeId provided " + binaryEncodingNodeId.toString());
        }
        const constructor = this.getConstructor(binaryEncodingNodeId);
        if (!constructor) {
            debugLog("Cannot find constructor for " + binaryEncodingNodeId.toString());
            throw new Error("Cannot find constructor for " + binaryEncodingNodeId.toString());
        }
        return new constructor();
    }
    associateWithBinaryEncoding(className, expandedNodeId) {
        const classConstructor = this.getStructureTypeConstructor(className);
        if (doDebug) {
            debugLog(" associateWithBinaryEncoding ", className, expandedNodeId.toString());
        }
        /* istanbul ignore next */
        if (!verifyExpandedNodeId(expandedNodeId)) {
            throw new Error("Invalid expandedNodeId " + expandedNodeId.toString() + " className = " + className);
        }
        const expandedNodeIdKey = makeExpandedNodeIdKey(expandedNodeId);
        /* istanbul ignore next */
        if (this._structureTypeConstructorByEncodingNodeIdMap.has(expandedNodeIdKey)) {
            throw new Error(" Class " +
                className +
                " with ID " +
                expandedNodeId +
                "  already in constructorMap for  " +
                this._structureTypeConstructorByEncodingNodeIdMap.get(expandedNodeIdKey).name);
        }
        this._structureTypeConstructorByEncodingNodeIdMap.set(expandedNodeIdKey, classConstructor);
    }
    toString() {
        const l = [];
        function write(...args) {
            l.push(util.format.apply(util.format, args));
        }
        dumpDataFactory(this, write);
        return l.join("\n");
    }
    _registerFactory(dataTypeNodeId, typeName, constructor) {
        /* istanbul ignore next */
        if (this.hasStructuredType(typeName)) {
            console.log(this.getStructureTypeConstructor(typeName));
            console.log("target namespace =", this.targetNamespace);
            throw new Error(" registerFactory  : " + typeName + " already registered");
        }
        debugLog("registering typeName ", typeName, dataTypeNodeId.toString());
        this._structureTypeConstructorByNameMap.set(typeName, constructor);
        if (dataTypeNodeId.value !== 0) {
            this._structureTypeConstructorByDataTypeMap.set(dataTypeNodeId.toString(), constructor);
        }
        Object.defineProperty(constructor.schema, "$$factory", {
            enumerable: false,
            value: this,
            writable: false
        });
    }
}
exports.DataTypeFactory = DataTypeFactory;
function dumpSchema(schema, write) {
    write("name           ", schema.name);
    write("dataType       ", schema.dataTypeNodeId.toString());
    write("binaryEncoding ", schema.encodingDefaultBinary.toString());
    for (const f of schema.fields) {
        write("          ", f.name.padEnd(30, " "), f.isArray ? true : false, f.fieldType);
    }
}
function dumpDataFactory(dataFactory, write) {
    for (const structureTypeName of dataFactory.structuredTypesNames()) {
        const schema = dataFactory.getStructuredTypeSchema(structureTypeName);
        write("structureTypeName =", structureTypeName);
        if (!dataFactory.getConstructorForDataType(schema.dataTypeNodeId)) {
            write("  ( No constructor for " + schema.name + "  " + schema.dataTypeNodeId.toString());
        }
        if (!schema.encodingDefaultBinary) {
            write(" (Schema has no encoding defaultBinary )");
        }
        else {
            if (dataFactory.hasConstructor(schema.encodingDefaultBinary)) {
                console.log("schema", schema.name);
                console.log("schema", schema.dataTypeNodeId.toString());
                console.log("schema", schema.encodingDefaultBinary ? schema.encodingDefaultBinary.toString() : " ");
                console.log("schema", schema.encodingDefaultXml ? schema.encodingDefaultXml.toString() : " ");
                // return;
                // throw new Error("Not  in Binary Encoding Map!!!!!  " + schema.encodingDefaultBinary);
            }
        }
        dumpSchema(schema, write);
    }
}
function verifyExpandedNodeId(expandedNodeId) {
    /* istanbul ignore next */
    if (expandedNodeId.value instanceof Buffer) {
        throw new Error("getConstructor not implemented for opaque nodeid");
    }
    return true;
}
function makeExpandedNodeIdKey(expandedNodeId) {
    return expandedNodeId.toString();
}
//# sourceMappingURL=datatype_factory.js.map